# Prim算法
Prim算法是一种常用的最小生成树算法，用于在给定无向连通图中找到最小生成树。最小生成树是一个连通子图，它包含了原图的所有顶点，并且具有最小的总权重或代价。

Prim算法的基本思想是从一个初始顶点开始，逐步地选择与当前最小生成树集合相连的最小权重边，并将其添加到最小生成树中。它的步骤如下：

1. 选择一个初始顶点，将其加入最小生成树集合。
2. 从已选择的顶点集合中找到与之相连的边，并选择权重最小的边。
3. 将选择的边加入最小生成树集合，并将该边的另一个顶点加入已选择的顶点集合。
4. 重复步骤2和步骤3，直到最小生成树集合中包含了所有顶点（或边的数量达到了顶点数减1）。

Prim算法使用一个优先队列（通常是最小堆）来选择权重最小的边。在每一步中，它选择与当前最小生成树集合相连的顶点中具有最小权重的边。这保证了每次选择的边都是当前最小生成树集合和未选择顶点集合之间的最小权重边。

通过使用Prim算法，我们可以在一个连通图中找到一棵最小生成树，该树具有最小的总权重或代价。这在许多应用中都是有用的，如网络设计、电力传输、城市规划等。


# leetcode 1584. 连接所有点的最小费用

<p>给你一个points 数组，表示 2D 平面上的一些点，其中 points[i] = [xi, yi] 。</p>

<p>连接点 [xi, yi] 和点 [xj, yj] 的费用为它们之间的 曼哈顿距离 ：|xi - xj| + |yi - yj| ，其中 |val| 表示 val 的绝对值。</p>

<p>请你返回将所有点连接的最小总费用。只有任意两点之间 有且仅有 一条简单路径时，才认为所有点都已连接。</p>


# 题解
## 1. 确认初始顶点，Prim算法并没有规定初始点怎么选，这里可以任选，默认取索引为0的点
```cpp
// 所有顶点，n×2的二维数组，每行记录了点的坐标
vector<vector<int>> points;

// 辅助数组，表示每个点是否已经被确认为已连接，避免重复搜索
vector<bool> connected(points.size(), false);

// 用索引来表示所有的点，初始确认连接的点为0
// 你要设为其它索引作为其实点也行，反正最后都要连上的
int start_index = 0;

// 初始顶点已连接
connected[start_index] = true;

// 初始顶点已连接
vector<int> path;
path.push_back(start_index);
```

## 2. 确认下一个连接点，在当前已经确定的点中查找最小边来确认新的点
### 2.1 曼哈顿距离计算，这一步可以提前算好存到一个预计算距离数组中，以便提升程序执行速度（空间换时间）
```cpp
// 计算曼哈顿距离
int Distance(int indexA, int indexB) {
    return std::abs(points[indexA][0] - points[indexB][0]) +
        std::abs(points[indexA][1] - points[indexB][1]);
}

// 存了所有坐标点距离的邻接矩阵缓存
vector<vector<int>> distance_cache;

// 预计算所有坐标点的距离
void CalcAllDistance(vector<vector<int>> &pts) {
    for (int i = 0; i < pts.size(); i++) {
        for (int j = i + 1; j < pts.size(); j++) {
            distance_cache[i][j] = distance_cache[j][i] = Distance(i, j);
        }
    }
}
```

### 2.2 在已连接的点集中查找最小边
```cpp
int total_cost = 0; // 最小总费用

// 查找最小边
void FindMinEdge() {
    int min_edge = INT_MAX; // 下一个最小边
    int min_point = -1; // 下一个连接最小边的点
    
    // 查找最小边
    for(auto pt: path) {
        for(int i=0; i<points.size(); i++) {
            // 排除和自己连接 && 排除已连接 && 最小距离
            if(pt!=i && !connected[i] && distance(pt, i)<min_edge)) {
                min_point = i;
                min_edge = distance(pt, i);
            }
        }
    }

    // 找到最小边后更新总费用和已连接数列
    if (min_point > 0 && min_edge > 0) {
        path.push_back(min_point);
        connected[min_point] = true;
        total_cost += min_edge;
    }
}
```

### 2.3 确认全部最小路径
```cpp
// 查找确认最小路径
while (path.size() < points.size()) {
    FindMinEdge();
}
```

## 3. 优化，上面的时间复杂度已经达到O(n^3)级别了，执行速度有点一言难尽
### 3.1 这里增加一个min_cost数组用来存剩余节点距离当前节点的最短距离
当前只有起始节点一个节点的时候很好理解，min_cost空间复杂度为O(n)
```cpp
// 最短距离
vector<int> min_cost(points.size(), INT_MAX);

// 初始确认连接的点为0
int start_index = 0;

// 其它点到起始点的距离
for (int i = 0; i < points.size(); i++) {
    if (i != start_index)
        min_cost[i] = distance_cache[start_index][i];
}
```

### 3.2 依据min_cost数据来查找最小边
```cpp
int min_edge = INT_MAX; // 下一个最小边
int min_point = -1; // 下一个连接最小边的点

for (int i = 0; i < points.size(); i++) {
    // 排除已连接 && 最小距离
    if (!connected[i] && min_cost[i] < min_edge) {
        min_point = i;
        min_edge = min_cost[i];
    }
}
```

### 3.3 渐进式更新min_cost数组
正常思维，存点阵之间相互的最短连接距离一般得要O(n^2)的时间复杂度，就是一开始用到的方法，每个已连接节点算一遍到剩余节点的距离，每次大循环都需要重新算一遍，就比较费时

这里因为起始点已经算过，假设我们从第二个已连接点开始算，依次计算剩余点到新连接点的距离，如果有比上一轮距离起始点还短的距离，则抛弃旧路径，保留新路径。这样每次就只用计算新增节点的权值，而不用迭代计算全部节点的权值。
```cpp
// 更新最短距离数列
for (int i = 0; i < points.size(); i++) {
    // 排除已连接 && 比当前最小边还小
    if(!connected[i] && min_cost[i] > distance_cache[i][min_point])
        min_cost[i] = distance_cache[i][min_point];
}
```

## 4. 完整代码
```cpp
class Prim {
public:
    Prim(vector<vector<int>>&& pts)
        : distance_cache(pts.size(), vector<int>(pts.size(), 0))
        , min_cost(pts.size(), INT_MAX)
        , connected(pts.size(), false)
        , points(pts) {

        // 预计算所有坐标点的距离
        CalcAllDistance(points);

        // 初始确认连接的点为0
        int start_index = 0;

        // 你要设为其它索引作为其实点也行，反正最后都要连上的
        connected[start_index] = true;
        path.push_back(start_index);

        // 其它点到起始点的距离
        for (int i = 0; i < points.size(); i++) {
            if (i != start_index)
                min_cost[i] = distance_cache[start_index][i];
        }

        // 查找确认最小路径
        while (path.size() < points.size()) {
            FindMinEdge();
        }
    }

    int MinCost() const {
        return total_cost;
    }

private:
    // 计算曼哈顿距离
    int Distance(int indexA, int indexB) {
        return std::abs(points[indexA][0] - points[indexB][0]) +
            std::abs(points[indexA][1] - points[indexB][1]);
    }

    // 预计算所有坐标点的距离
    void CalcAllDistance(vector<vector<int>> &pts) {
        for (int i = 0; i < pts.size(); i++) {
            for (int j = i + 1; j < pts.size(); j++) {
                distance_cache[i][j] = distance_cache[j][i] = Distance(i, j);
            }
        }
    }

    // 查找最小边
    void FindMinEdge() {
        // 下一个最小边
        int min_edge = INT_MAX;
        // 下一个连接最小边的点
        int min_point = -1;

        for (int i = 0; i < points.size(); i++) {
            // 排除已连接 && 最小距离
            if (!connected[i] && min_cost[i] < min_edge) {
                min_point = i;
                min_edge = min_cost[i];
            }
        }

        // 找到最小边后更新总费用和已连接数列
        if (min_point > 0 && min_edge > 0) {
            path.push_back(min_point);
            connected[min_point] = true;
            total_cost += min_edge;
        }

        // 更新最短距离数列
        for (int i = 0; i < points.size(); i++) {
            // 排除已连接 && 比当前最小边还小
            if(!connected[i] && min_cost[i] > distance_cache[i][min_point])
                min_cost[i] = distance_cache[i][min_point];
        }
    }

private:
    // 存了所有坐标点距离的邻接矩阵缓存
    vector<vector<int>> distance_cache;
    // 最短距离
    vector<int> min_cost;
    // 辅助数组，表示每个点是否已经被确认为已连接，避免重复搜索
    vector<bool> connected;
    // points是一个二维数组，每行存了一个点的XY坐标
    vector<vector<int>> points;
    // 已经确定的连接点的索引数列
    vector<int> path;
    // 最小总费用
    int total_cost{ 0 };
};


class Solution {
public:
    static int minCostConnectPoints(vector<vector<int>>& points) {
        Prim p(std::move(points));
        return p.MinCost();
    }
};

void Test() {
    // 20
    vector<vector<int>> pts = {
        {0,0},{2,2},{3,10},{5,2},{7,0}};
    cout << Solution::minCostConnectPoints(pts) << endl;

    // 351638
    pts = {
        {-5698,-8233},{1026,4797},{8195,8437},{3498,-9980},{5222,-4322},{-5589,-7532},{2098,-3463},{-9603,-3604},{-6057,8315},{-1259,2835},{-728,-4985},{-7736,-1357},{-3403,912},{307,3130},{-7891,-1896},{5347,4345},{-4634,718},{205,-9439},{5061,2060},{-6672,-9647},{5682,7606},{-1954,-5638},{9478,-2673},{-1520,-3300},{4245,7018},{-9850,-1419},{9311,-4321},{-8522,9196},{8161,4077},{78,6893},{-250,3376},{-5764,-6641},{-9870,-2137},{6358,477},{2145,-6866},{2677,1564},{-394,-8628},{-9669,2688},{-6124,8802},{4731,-6891},{6841,-4542},{-849,-5183},{-5049,6470},{752,9487},{-2382,-787},{-2679,7391},{-4088,4983},{9609,7633},{5588,-4217},{2029,9029},{5166,2772},{-2614,2036},{9452,5837},{-1398,-4690},{5367,-9452},{2557,4278},{3018,8427},{-5050,-3043},{-3402,9306},{5905,-886},{-5711,7472},{-4855,-7741},{-3874,-8015},{6662,7579},{7111,5400},{-6518,835},{8744,7618},{-5018,6824},{2967,1579},{-9125,1051},{4453,3851},{1745,-1764},{4243,2062},{9773,7988},{-908,9980},{4519,7744},{-5959,8796},{-1050,-8178},{496,7536},{161,4729},{-2559,-2468},{-8038,-6269},{-2701,-3586},{3054,-4072},{-5171,2062},{-6688,3479},{4423,-3834},{-8404,-723},{-1316,8726},{-2303,-1381},{4793,5648},{-4862,5489},{-772,-8258},{851,-9830},{-5218,-5705},{-5323,7785},{-7762,-8046},{7317,1475},{1820,-4586},{2150,140},{-4643,4190},{-2389,-5398},{-786,-9999},{5768,-208},{5908,-3623},{-869,5566},{-3238,6606},{-1247,6673},{113,-9718},{-1819,-7680},{9333,1395},{-9716,-9202},{-5926,3456},{-1893,-2083},{-6634,-1278},{-5122,-8749},{8528,1204},{-1210,-2230},{-2195,4983},{9539,-4935},{-2339,5310},{-153,-7579},{4629,-7497},{294,-6041},{7572,-8638},{3024,-4783},{-2416,2260},{-3728,2560},{-6499,3001},{7706,6003},{8700,5144},{-54,6420},{-5355,7235},{-7327,7085},{1379,7006},{-6631,4364},{8590,-2063},{124,-991},{4997,-732},{8748,-2321},{8827,-5733},{-9958,7106},{6999,9696},{-6653,4769},{-6316,8075},{-5669,-1720},{5473,-2215},{4798,8281},{4174,-717},{9465,-6092},{7763,9754},{-2942,-4927},{-9770,-2867},{-8570,4194},{-801,6443},{-7374,3245},{-5159,-1232},{189,9554},{-9721,-27},{6907,-6585},{-859,-3675},{-6841,8855},{8934,-9852},{1675,-7822},{-6489,-8706},{-7575,6401},{-546,178},{5666,-6399},{6841,7530},{4665,-7514},{-1565,-1960},{-3214,3199},{-8671,8382},{-1780,-2431},{5434,-8329},{-6027,-2661},{8458,-9085},{881,-5237},{-2343,6666},{5584,-9490},{4027,5207},{-4352,8676},{-4678,110},{-6308,3922},{6848,9570},{-2108,-2837},{-6291,-4718},{1659,4767},{1723,-4909},{-5944,-6446},{6548,9498},{-8475,-1982},{4598,-3275},{8346,5422},{5298,-6086},{2005,-7830},{-4528,3574},{5557,-9429},{-8988,-4465},{-5814,-9101},{2809,5688},{1525,5986},{-2094,-4340},{2089,7047},{-6276,2758},{423,2767},{4590,-5166},{5637,5134},{8738,-3710},{-418,6321},{-3450,-9162},{-6105,-8925},{285,-6936},{-6194,6073},{4258,1301},{-5567,-1161},{4306,-2707},{1113,5653},{-4610,-2182},{1987,-24},{1374,4615},{1320,5650},{-9531,5679},{1195,1394},{-8347,-8318},{114,438},{-6603,-3452},{-6512,-9403},{2763,3338},{-4136,3306},{1350,-958},{6573,-4548},{-5830,-7189},{6149,-2963},{-6957,1571},{-2225,-7921},{-6151,6881},{-2954,3537},{628,3738},{8103,6531},{-1959,821},{-8322,1729},{3933,-6371},{-2922,-2509},{-8441,-3109},{2677,3230},{8645,3667},{-6378,-3285},{8870,-4684},{-8930,2032},{-3529,1453},{637,-5024},{-8292,2526},{5663,-5360},{-8694,-2729},{-8333,-1188},{-5749,2871},{2538,-9028},{-5990,-118},{7641,-1651},{-1312,5346},{8578,-4859},{-9958,9666},{4485,-4112},{4067,-3731},{-4199,-6144},{-9647,-6230},{-5366,-6184},{-803,-7515},{2075,3361},{3442,828},{3661,1253},{-6315,-4061},{214,-6752},{4305,3912},{-8961,9710},{4404,8651},{3338,-7},{-2860,6387},{5744,2278},{4214,-7730},{-1884,-7994},{5151,8701},{-3897,8828},{-8642,5586},{3482,7427},{-9509,1333},{-2108,5560},{-3340,7145},{8741,2428},{-5170,1157},{690,-9469},{-312,1334},{-8163,-2838},{-7934,-7494},{7417,-9102},{-5876,-9336},{-5080,-7916},{-5536,9034},{6545,-1656},{4362,498},{-917,933},{-7214,5875},{1411,1117},{-3357,5667},{-3406,3817},{-3980,-9798},{-4892,797},{-8927,8941},{-2861,-5003},{-3183,2331},{1632,-9390},{6131,1978},{8993,9089},{-2151,-9220},{-8772,-6323},{-2458,6153},{8078,-4117},{-3571,3464},{-877,-7206},{6074,-5182},{-9085,-4133},{-6966,-4049},{9538,-8572},{7752,-196},{6887,8882},{-7154,7452},{-1800,7320},{-9736,7263},{1265,7537},{4684,-8260},{2572,4413},{-2022,1650},{2676,-3224},{5784,-2351},{-52,1375},{8735,-7509},{3338,9006},{7267,3251},{-1434,-7395},{6737,-4749},{68,6977},{-9757,-9738},{6935,-9525},{3486,5691},{4894,-6794},{5658,-2055},{2907,-9576},{-6947,-4678},{-9639,7740},{-6644,-7749},{-1758,4464},{-1164,-7809},{1320,8410},{-4209,5625},{-5332,6191},{3355,-155},{6578,-1843},{-8754,-8416},{-2439,-3218},{2036,-4770},{-484,-9929},{653,5591},{-7623,9241},{-6899,6623},{-7281,-4130},{3617,1483},{7161,-4357},{8987,-1159},{1849,1262},{-9027,8958},{992,-420},{1220,-6801},{-9770,-3730},{5156,4240},{-8355,-1884},{-5820,-358},{6255,8001},{-7344,-4709},{-8505,8209},{-9564,-9172},{1032,-604},{-1083,-2613},{-2190,-6519},{1882,-8574},{-5445,-2921},{7177,358},{2256,-8305},{790,8004},{1089,-1798},{8344,-921},{-8075,-59},{-4279,2544},{-3052,-9733},{-985,3404},{-3351,-6341},{-6097,-7971},{-3188,-4125},{2824,5943},{2294,-6651},{-920,-6433},{-6783,4957},{-9948,7901},{-7464,3816},{-6063,-1903},{791,-8022},{-2200,-7450},{2480,1872},{-6795,5060},{9765,413},{9183,9179},{4942,8703},{-8213,-654},{4930,2730},{6358,6589},{8222,-9670},{9857,1241},{4159,-269},{7318,2587},{-9114,2789},{-5124,-9881},{-5525,7263},{-7584,-1725},{9413,-3888},{-9749,2216},{-8622,-419},{3274,-8722},{6234,-6800},{-9116,7304},{-8765,-471},{-7918,-9246},{5972,-470},{3310,7609},{8711,2677},{-2045,5514},{-5871,17},{-9705,2204},{6577,297},{7771,6640},{-1002,-3492},{-2487,-9394},{6992,-3892},{9585,-9475},{8108,6050},{-9513,-5036},{-9110,750},{-1192,1627},{9879,-9908},{-4519,-2218},{-6230,6680},{-9091,7684},{-6892,4007},{9652,6787}};
    cout << Solution::minCostConnectPoints(pts) << endl;
}
```

# Prim算法和Kruskal算法的区别
Prim算法和Kruskal算法都是用于求解最小生成树的经典算法，它们的主要区别在于实现方式和时间复杂度。

Prim算法是一种贪心算法，其基本思想是从一个任意选定的起始节点开始，每次选择与当前生成树相邻的最短边的另一个端点加入到生成树中，直到所有节点都被加入到生成树中为止。该算法可以使用堆优化的方式，时间复杂度为O(ElogV)，其中E和V分别为边数和顶点数。

Kruskal算法也是一种贪心算法，其基本思想是将所有边按照权值从小到大排序，然后逐步加入边，如果加入某条边会形成环，则舍弃该边，直到所有节点都被加入到生成树中为止。该算法使用并查集来判断是否形成环，时间复杂度为O(ElogE)，其中E为边数。

因此，Prim算法更适用于稠密图（即边数较多），而Kruskal算法更适用于稀疏图（即边数较少）。此外，Prim算法的空间复杂度比Kruskal算法小，因为Prim算法只需要存储每个节点到生成树的最短距离，而Kruskal算法需要存储每个节点所在的集合。

# 参考
[0] Prim's algorithm https://en.wikipedia.org/wiki/Prim%27s_algorithm

[1] leetcode 1584. 连接所有点的最小费用 https://leetcode.cn/problems/min-cost-to-connect-all-points/description/

[2] 计程车几何（Taxicab geometry）或曼哈顿距离 https://en.wikipedia.org/wiki/Taxicab_geometry